snippet Inc "#include local header (inc)"
#include "${1:`!p snip.rv = snip.basename + '.hpp'`}"
endsnippet

snippet inv "include with clipboard content"
#include "`!v getreg("*")`"
endsnippet

snippet ins "$include STL header file" !b
#include <${1:iostream}>
endsnippet

snippet inc "#include <header.hpp>" !b
#include <${1:header}.hpp>
endsnippet

snippet in "#include xxx.hpp" !b
#include "${1:header}.hpp"
endsnippet

snippet un "using namespace" b
using namespace ${1:UserInterface};
endsnippet

snippet ustd "using namespace std" b
using namespace std;
endsnippet

snippet forui "for int loop (fori)"
for (unsigned ${1:i} = ${3:0}; $1 < ${2:count}; ++$1)
{
    ${VISUAL}${0:${VISUAL/(.*)/(?1::\/* code *\/)/}}
}
endsnippet

snippet fori "for int loop (fori)"
for (int ${1:i} = ${3:0}; $1 < ${2:count}; ++$1)
{
    ${VISUAL}${0:${VISUAL/(.*)/(?1::\/* code *\/)/}}
}
endsnippet

snippet foriter "for loop iterator form"
${1:container_type}::iterator iter = ${2:container}.begin();
for (; iter != $2.end(); ++iter)
{
    $0
}
endsnippet

snippet ifd "Include header guard"
#ifndef `!p snip.rv = fn.replace(".","_").upper()`
#define `!p snip.rv = fn.replace(".","_").upper()`

$0

#endif
endsnippet

snippet cls "class xxx"
class ${1:`!p snip.rv = snip.basename or "name"`}
{
public:
    ${1/(\w+).*/$1/} (${2:arguments});
    virtual ~${1/(\w+).*/$1/} ();

    $0

private:
    ${1/(\w+).*/$1/} (const ${1/(\w+).*/$1/}& rhs); // do not implement
    ${1/(\w+).*/$1/}& operator= (const ${1/(\w+).*/$1/}& rhs); // do not implement

    ${2:/* TODO: members */}
};
endsnippet

snippet ifc "pure interface class"
class ${1:`!p snip.rv = snip.basename or "name"`}
{
public:
    virtual ~${1/(\w+).*/$1/} () {}; 

    $0
};
endsnippet

snippet sgt "singleton class"
class ${1:`!p snip.rv = snip.basename or "name"`}
{
public:
    static ${1/(\w+).*/$1/}& GetInstance();
    $0

private:
    ${1/(\w+).*/$1/} (${2:arguments});

    ${1/(\w+).*/$1/} (const ${1/(\w+).*/$1/}& rhs); // do not implement
    ${1/(\w+).*/$1/}& operator= (const ${1/(\w+).*/$1/}& rhs); // do not implement

    ${3:/* TODO: members */}
};
endsnippet

snippet fc "function implementation"
${1:void} ${2:class}::${3:function}(${4:argument})
{
    ${5:/*code*/}
}
endsnippet

snippet fd "function declaration"
${1:void} ${2:function}(${4:argument});
endsnippet

snippet cfd "const function declaration"
${1:void} ${2:function}(${4:argument}) const;
endsnippet

snippet as "ASSERT(xxxx)"
ASSERT(${1:condition});
endsnippet

snippet asp "ASSERT(pointer != NULL)"
ASSERT(${1:pointer} != NULL);

if (!$1)
{
    $0
}

endsnippet

snippet iter "get an iterator"
${1:container_type}::iterator iter = ${2:container}.${3:begin()};
endsnippet

snippet b "start a block" i

{
    $0
}
endsnippet

snippet bv "put visual selection in a block"
{
    ${VISUAL:}
}
endsnippet

snippet ex "extract the visual selection into a new function for refactor purpose"
${1:void} `!p snip.rv = snip.basename`::${2:function}(${3:arguments})
{
    ${VISUAL:}
    ${4}
}
endsnippet

snippet t
<tag>${VISUAL:inside text/should/is/g}</tag>
endsnippet

snippet ctor "constructor"
`!p snip.rv = snip.basename`::`!p snip.rv = snip.basename`()
{
}
endsnippet

snippet dtor "destructor"
`!p snip.rv = snip.basename`::~`!p snip.rv = snip.basename`()
{
}
endsnippet

snippet cs "adding ClassName::"
`!p snip.rv = snip.basename`::
endsnippet

snippet pc "pointer check code"
ASSERT(${1:pointer});
if (!$1)
{
    return ${2:false};
}
$0
endsnippet

snippet pv "pure virtual method"
virtual ${1:void} ${2:name}(${3:args}) = 0;
endsnippet

snippet debugstr "debug string"
{
    char buffer[256];
    wsprintf(buffer, "${1:debug message here}", ${2:variable});
    OutputDebugString(buffer);
}
endsnippet

snippet stc "static const declaration and definition" b
static const ${1:unsigned} ${2:var};
const $1 `!p snip.rv = snip.basename`::$2 = ${3};
endsnippet

snippet sca "static cast" w
static_cast<$1>(${VISUAL})
endsnippet

snippet cwp "Console.WriteLine with parameters" b
Console.WriteLine("${2:`!p
snip.rv = ' '.join(['{' + str(i) + '}' for i in range(t[1].count(','))])
`}"${1:, something});
endsnippet
