snippet 2darray "2d array"
${1:int}** ${2:grid} = new $1*[${3:ROW}];
for (int i = 0; i < $3; ++i)
{
    $2[i] = new $1[${4:COLUMN}];
}
endsnippet

snippet for2 "two level loop"
for (int i = 0; i < ${1:l}; ++i)
{
    for (int j = 0; j < ${2:k}; ++j)
    {
        ${VISUAL}${0:${VISUAL/(.*)/(?1::\/* code *\/)/}}
    }
}
endsnippet

snippet ~ "home"
/Users/showgood/
endsnippet

snippet input "ifstream input(input.txt)"
ifstream input("input.txt");
endsnippet

snippet out "ofstream out(out.txt)"
ofstream out("out.txt");
endsnippet

snippet freopen "freopen"
freopen("input.txt", "r", stdin);
freopen("out.txt", "w", stdout);
endsnippet

snippet rt "return"
return ${1:0};
endsnippet

snippet skl "cpp skeleton file with main()"
#include <iostream>
using namespace std;

int main(int argc, char *argv[])
{
    ${VISUAL}${0:${VISUAL/(.*)/(?1::\/* code *\/)/}}
    return 0;
}
endsnippet

snippet pbk "vector.push_back()"
${1:vector}.push_back($2);
endsnippet

snippet forj "for loop (--i)"
for (${1:i} = ${2:count}; $1 ${3:>=} ${4:0}; ${5:--$1})
{
    ${VISUAL}${0:${VISUAL/(.*)/(?1::\/* code *\/)/}}
}
endsnippet

snippet vt "std::vector (v)"
std::vector<${1:int}> $2;
endsnippet

snippet vi "std::vector (int)"
std::vector<int> $1;
endsnippet

snippet vs "std::vector (string)"
std::vector<string> $1;
endsnippet

snippet map "std::map (map)"
std::map<${1:int}, ${2:string}> $3;
endsnippet

snippet mtc "multiple test cases"
int testCase = 0;
cin >> testCase;

while (testCase)
{
    ${1:do something}
    --testCase;
}
endsnippet

snippet algo "#include <algorithm>"
#include <algorithm>
endsnippet

snippet Inc "#include local header (inc)"
#include "${1:`!p snip.rv = snip.basename + '.hpp'`}"
endsnippet

snippet inv "include with clipboard content"
#include "`!v getreg("*")`"
endsnippet

snippet ins "$include STL header file" !b
#include <${1:iostream}>
endsnippet

snippet inc "#include <header.hpp>" !b
#include <${1:header}.hpp>
endsnippet

snippet in "#include xxx.hpp" !b
#include "${1:header}.hpp"
endsnippet

snippet ifv "if .. (if)"
if (${VISUAL:})
{
    ${0:${VISUAL/(.*)/(?1::\/* code *\/)/}}
}
endsnippet

snippet un "using namespace" b
using namespace ${1:UserInterface};
endsnippet

snippet ustd "using namespace std" b
using namespace std;
endsnippet

snippet forui "for unsigned i loop (++i)"
for (unsigned ${1:i} = ${3:0}; $1 < ${2:count}; ++$1)
{
    ${VISUAL}${0:${VISUAL/(.*)/(?1::\/* code *\/)/}}
}
endsnippet

snippet fori "for int loop (++i)"
for (int ${1:i} = ${3:0}; $1 < ${2:count}; ++$1)
{
    ${VISUAL}${0:${VISUAL/(.*)/(?1::\/* code *\/)/}}
}
endsnippet

snippet foriter "for loop iterator form"
${1:container_type}::iterator iter = ${2:container}.begin();
for (; iter != $2.end(); ++iter)
{
    $0
}
endsnippet

snippet ifd "Include header guard"
#ifndef `!p snip.rv = fn.replace(".","_").upper()`
#define `!p snip.rv = fn.replace(".","_").upper()`

$0

#endif
endsnippet

snippet cls "class xxx"
class ${1:`!p snip.rv = snip.basename or "name"`}
{
public:
    ${1/(\w+).*/$1/} (${2:arguments});
    virtual ~${1/(\w+).*/$1/} ();

    $0

private:
    ${1/(\w+).*/$1/} (const ${1/(\w+).*/$1/}& rhs); // do not implement
    ${1/(\w+).*/$1/}& operator= (const ${1/(\w+).*/$1/}& rhs); // do not implement

    ${2:/* TODO: members */}
};
endsnippet

snippet ifc "pure interface class"
class ${1:`!p snip.rv = snip.basename or "name"`}
{
public:
    virtual ~${1/(\w+).*/$1/} () {}; 

    $0
};
endsnippet

snippet sgt "singleton class"
class ${1:`!p snip.rv = snip.basename or "name"`}
{
public:
    static ${1/(\w+).*/$1/}& GetInstance();
    $0

private:
    ${1/(\w+).*/$1/} (${2:arguments});

    ${1/(\w+).*/$1/} (const ${1/(\w+).*/$1/}& rhs); // do not implement
    ${1/(\w+).*/$1/}& operator= (const ${1/(\w+).*/$1/}& rhs); // do not implement

    ${3:/* TODO: members */}
};
endsnippet

snippet cfunc "class member function implementation"
${1:void} ${2:class}::${3:function}(${4:argument})
{
    ${5:/*code*/}
}
endsnippet

snippet fund "function declaration"
${1:void} ${2:function}(${3:argument});
endsnippet

snippet cfund "const function declaration"
${1:void} ${2:function}(${4:argument}) const;
endsnippet

snippet as "ASSERT(xxxx)"
ASSERT(${1:condition});
endsnippet

snippet asp "ASSERT(pointer != NULL)"
ASSERT(${1:pointer} != NULL);

if (!$1)
{
    $0
}

endsnippet

snippet iter "get an iterator"
${1:container_type}::iterator iter = ${2:container}.${3:begin()};
endsnippet

snippet b "start a block" i

{
    $0
}
endsnippet

snippet bv "put visual selection in a block"
{
    ${VISUAL:}
}
endsnippet

snippet ex "extract the visual selection into a new function for refactor purpose"
${1:void} `!p snip.rv = snip.basename`::${2:function}(${3:arguments})
{
    ${VISUAL:}
    ${4}
}
endsnippet

snippet t
<tag>${VISUAL:inside text/should/is/g}</tag>
endsnippet

snippet ctor "constructor"
`!p snip.rv = snip.basename`::`!p snip.rv = snip.basename`()
{
}
endsnippet

snippet dtor "destructor"
`!p snip.rv = snip.basename`::~`!p snip.rv = snip.basename`()
{
}
endsnippet

snippet cs "adding ClassName::"
`!p snip.rv = snip.basename`::
endsnippet

snippet pc "pointer check code"
ASSERT(${1:pointer});
if (!$1)
{
    return ${2:false};
}
$0
endsnippet

snippet pv "pure virtual method"
virtual ${1:void} ${2:name}(${3:args}) = 0;
endsnippet

snippet debugstr "debug string"
{
    char buffer[256];
    wsprintf(buffer, "${1:debug message here}", ${2:variable});
    OutputDebugString(buffer);
}
endsnippet

snippet sco "static const declaration and definition" b
static const ${1:unsigned} ${2:var};
const $1 `!p snip.rv = snip.basename`::$2 = ${3};
endsnippet

snippet sca "static cast" w
static_cast<$1>(${VISUAL})
endsnippet

snippet cwp "Console.WriteLine with parameters" b
Console.WriteLine("${2:`!p
snip.rv = ' '.join(['{' + str(i) + '}' for i in range(t[1].count(','))])
`}"${1:, something});
endsnippet

# vim:ft=snippets:
